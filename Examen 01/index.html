<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Juego Ambulancia - Babylon.js</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>

<body>
<canvas id="renderCanvas"></canvas>
<script>
    // CONSTANTES DE CONFIGURACIÓN DEL ESCENARIO
    const CONFIG = {
        // Carreteras
        ROAD_WIDTH: 12,
        ROAD_HEIGHT: 105,
        ROAD1_POS: { x: 0, z: 50 },
        ROAD2_POS: { x: 30, z: 50 },

        // Curva
        CURVE_RADIUS: 15,
        CURVE_SEGMENTS: 40,
        CURVE_CENTER: { x: 15, z: 100 },
        CURVE_HALF_WIDTH: 7.5,

        // Aceras
        SIDEWALK_WIDTH: 3,
        SIDEWALK_POS_X: [7.5, -7.5],

        // Pasto
        GRASS_WIDTH: 100,
        GRASS_HEIGHT: 140,
        GRASS_POS: { x: 15, y: -0.05, z: 65 },

        // Decoración (árboles, farolas)
        TREES_COUNT: 10,
        TREE_POS: { x: -15 },
        LAMP_POS: { x: 15 },

        // Casas
        HOUSES_COUNT: 5,
        HOUSE_OFFSET: 20,
        HOUSE_INITIAL: 5,

        // Skybox
        SKYBOX_SIZE: 200,
        SKYBOX_POS: { x: 15, y: -50, z: 70 },

        // Movimieno ambulancia
        AMBULANCE_SPEED: 0.5,
        AMBULANCE_ROTATION_SPEED: 0.03,
        AMBULANCE_BOUNDS: {
            minX: -35, maxX: 65,
            minZ: -5, maxZ: 135
        },

        // Luz
        LIGHT_INTENSITY: 0.9,

        // Paciente
        PATIENT_SPAWN_Z_RANGE: 100,
        PATIENT_PICKUP_RANGE: 5,
        PATIENT_DELIVERY_RANGE: 4,
    };

    const COLORS = {
        ROAD: new BABYLON.Color3(0.1, 0.1, 0.1),
        SIDEWALK: new BABYLON.Color3(0.8, 0.8, 0.8),
        GRASS: new BABYLON.Color3(0.2, 0.7, 0.2),
        TREE_TRUNK: new BABYLON.Color3(0.5, 0.3, 0.1),
        TREE_LEAVES: new BABYLON.Color3(0.1, 0.6, 0.1),
        LAMP_POLE: new BABYLON.Color3(0.7, 0.7, 0.7),
        LAMP_LIGHT: new BABYLON.Color3(1, 1, 0.7),
        HOUSE_WALL: new BABYLON.Color3(1, 1, 1),
        HOUSE_ROOF: new BABYLON.Color3(0.7, 0.1, 0.1),
        LINE_ROAD: new BABYLON.Color3(1, 1, 0),
        CURB: new BABYLON.Color3(1, 1, 1),
    };

    // VARIABLES GLOBALES AGRUPADAS EN UN SOLO OBJETO
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const game = {
        scene: null,
        ambulancia: null,
        paciente: null,
        hospital: null,
        tienePaciente: false,
        inputMap: {},
        contadorPacientes: 0,
        patientLight: null,
        patientRings: [],
        hologramTime: 0,
        contadorText: null,
    };

    // HELPERS Y UTILIDADES
    function crearMaterial(nombre, color, sceneRef) {
        const mat = new BABYLON.StandardMaterial(nombre, sceneRef);
        mat.diffuseColor = color;
        return mat;
    }

    function crearParedColision(nombre, dimensiones, posicion, sceneRef, rotY = 0) {
        const pared = BABYLON.MeshBuilder.CreateBox(nombre, dimensiones, sceneRef);
        pared.position = posicion;
        if (rotY) pared.rotation = new BABYLON.Vector3(0, rotY, 0);
        pared.isVisible = false;
        pared.checkCollisions = true;
        return pared;
    }

    // FUNCIONES DE CREACIÓN DEL ESCENARIO
    function crearSkybox(sceneRef) {
        const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: CONFIG.SKYBOX_SIZE }, sceneRef);
        skybox.position = new BABYLON.Vector3(CONFIG.SKYBOX_POS.x, CONFIG.SKYBOX_POS.y, CONFIG.SKYBOX_POS.z);

        const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMat", sceneRef);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/TropicalSunnyDay", sceneRef);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;

        return skybox;
    }

    function crearCarreteras(sceneRef) {
        const roadMat = crearMaterial("roadMat", COLORS.ROAD, sceneRef);

        // Carretera 1
        const road = BABYLON.MeshBuilder.CreateGround("road", { width: CONFIG.ROAD_WIDTH, height: CONFIG.ROAD_HEIGHT }, sceneRef);
        road.material = roadMat;
        road.position.x = CONFIG.ROAD1_POS.x;
        road.position.z = CONFIG.ROAD1_POS.z;
        road.checkCollisions = true;

        // Carretera 2
        const roadReturn = BABYLON.MeshBuilder.CreateGround("roadReturn", { width: CONFIG.ROAD_WIDTH, height: CONFIG.ROAD_HEIGHT }, sceneRef);
        roadReturn.material = roadMat;
        roadReturn.position.x = CONFIG.ROAD2_POS.x;
        roadReturn.position.z = CONFIG.ROAD2_POS.z;
        roadReturn.checkCollisions = true;

        return { road, roadReturn, roadMat };
    }

    function crearCurva(sceneRef, roadMat) {
        const curvePath = [];
        const curveSegments = CONFIG.CURVE_SEGMENTS;
        const curveRadius = CONFIG.CURVE_RADIUS;
        const cx = CONFIG.CURVE_CENTER.x;
        const cz = CONFIG.CURVE_CENTER.z;

        for (let i = 0; i <= curveSegments; i++) {
            const t = i / curveSegments;
            const theta = Math.PI - Math.PI * t;
            const x = cx + curveRadius * Math.cos(theta);
            const z = cz + curveRadius * Math.sin(theta);
            curvePath.push(new BABYLON.Vector3(x, 0, z));
        }

        const roadShape = [
            new BABYLON.Vector3(-CONFIG.CURVE_HALF_WIDTH, 0, 0),
            new BABYLON.Vector3(CONFIG.CURVE_HALF_WIDTH, 0, 0)
        ];

        const roadCurve = BABYLON.MeshBuilder.ExtrudeShape("roadCurve", {
            shape: roadShape,
            path: curvePath,
            cap: BABYLON.Mesh.CAP_ALL,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
        }, sceneRef);

        roadCurve.material = roadMat;
        roadCurve.position.y = 0.01;
        roadCurve.checkCollisions = true;

        return { roadCurve, curvePath };
    }

    function crearAceras(sceneRef, curvePath) {
        const sidewalkMat = crearMaterial("sidewalkMat", COLORS.SIDEWALK, sceneRef);
        const halfWidth = 6;
        const sidewalkHalfWidth = 1.5;

        // Aceras en carretera 1 (ida)
        for (let side of [-1, 1]) {
            const sidewalk = BABYLON.MeshBuilder.CreateGround("sidewalk" + side,
                { width: CONFIG.SIDEWALK_WIDTH, height: CONFIG.ROAD_HEIGHT }, sceneRef);
            sidewalk.material = sidewalkMat;
            sidewalk.position.x = side * 7.5;
            sidewalk.position.z = CONFIG.ROAD1_POS.z;
        }

        // Aceras en carretera 2 (regreso)
        for (let side of [-1, 1]) {
            const sidewalkReturn = BABYLON.MeshBuilder.CreateGround("sidewalkReturn" + side,
                { width: CONFIG.SIDEWALK_WIDTH, height: CONFIG.ROAD_HEIGHT }, sceneRef);
            sidewalkReturn.material = sidewalkMat;
            sidewalkReturn.position.x = side * 7.5 + 30;
            sidewalkReturn.position.z = CONFIG.ROAD2_POS.z;
        }

        // Aceras en curva
        for (let side of [-1, 1]) {
            const offset = halfWidth + 1.5;
            const shape = [
                new BABYLON.Vector3(-sidewalkHalfWidth, 0, 0),
                new BABYLON.Vector3(sidewalkHalfWidth, 0, 0)
            ];
            const pathCurve = curvePath.map((p, idx) => {
                const dir = (idx < curvePath.length - 1)
                    ? curvePath[idx + 1].subtract(p).normalize()
                    : curvePath[idx].subtract(curvePath[idx - 1]).normalize();
                const normal = new BABYLON.Vector3(-dir.z, 0, dir.x);
                return p.add(normal.scale(side * offset));
            });
            const sidewalkCurve = BABYLON.MeshBuilder.ExtrudeShape(`sidewalkCurve${side}`, {
                shape: shape,
                path: pathCurve,
                cap: BABYLON.Mesh.CAP_ALL,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, sceneRef);
            sidewalkCurve.position.y = 0.05;
            sidewalkCurve.material = sidewalkMat;
        }
    }

    // Helper para crear árbol + farola en una posición base
    function crearArbolYFarola(sceneRef, xArbol, xFarola, zBase, index, prefix) {
        // Árbol
        const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk_" + prefix + index, { diameter: 0.3, height: 2 }, sceneRef);
        trunk.position = new BABYLON.Vector3(xArbol, 1, zBase);
        trunk.material = crearMaterial("trunkMat_" + prefix + index, COLORS.TREE_TRUNK, sceneRef);

        const leaves = BABYLON.MeshBuilder.CreateSphere("leaves_" + prefix + index, { diameter: 2 }, sceneRef);
        leaves.position = new BABYLON.Vector3(xArbol, 2.5, zBase);
        leaves.material = crearMaterial("leavesMat_" + prefix + index, COLORS.TREE_LEAVES, sceneRef);

        // Farola
        const pole = BABYLON.MeshBuilder.CreateCylinder("pole_" + prefix + index, { diameter: 0.1, height: 3 }, sceneRef);
        pole.position = new BABYLON.Vector3(xFarola, 1.5, zBase + 2);
        pole.material = crearMaterial("poleMat_" + prefix + index, COLORS.LAMP_POLE, sceneRef);

        const lamp = BABYLON.MeshBuilder.CreateSphere("lamp_" + prefix + index, { diameter: 0.3 }, sceneRef);
        lamp.position = new BABYLON.Vector3(xFarola, 3, zBase + 2);
        lamp.material = crearMaterial("lampMat_" + prefix + index, COLORS.LAMP_LIGHT, sceneRef);
    }

    function crearDecoracion(sceneRef) {
        // Pasto
        const grass = BABYLON.MeshBuilder.CreateGround("grass",
            { width: CONFIG.GRASS_WIDTH, height: CONFIG.GRASS_HEIGHT }, sceneRef);
        const grassMat = crearMaterial("grassMat", COLORS.GRASS, sceneRef);
        grassMat.specularColor = new BABYLON.Color3(0, 0, 0);
        grass.material = grassMat;
        grass.position.x = CONFIG.GRASS_POS.x;
        grass.position.z = CONFIG.GRASS_POS.z;
        grass.position.y = CONFIG.GRASS_POS.y;

        // Árboles y farolas en ambas carreteras
        for (let i = 0; i < CONFIG.TREES_COUNT; i++) {
            const z = i * 10;

            // Carretera 1
            crearArbolYFarola(sceneRef, CONFIG.TREE_POS.x, CONFIG.LAMP_POS.x, z, i, "c1");

            // Carretera 2
            crearArbolYFarola(sceneRef, 15, 45, z, i, "c2");
        }
    }

    function crearLineasYBordes(sceneRef, curvePath) {
        const carreteras = [
            { x: CONFIG.ROAD1_POS.x, nombre: "carretera 1" },
            { x: CONFIG.ROAD2_POS.x, nombre: "carretera 2" }
        ];

        carreteras.forEach((car, idxCar) => {
            for (let i = 0; i < 10; i++) {
                // Líneas centrales
                const line = BABYLON.MeshBuilder.CreateBox(`line_${idxCar}_${i}`, { width: 0.5, height: 0.1, depth: 4 }, sceneRef);
                line.position = new BABYLON.Vector3(car.x, 0.05, i * 10);
                line.material = crearMaterial(`lineMat_${idxCar}_${i}`, COLORS.LINE_ROAD, sceneRef);

                // Bordes (ambos lados)
                for (let side of [-1, 1]) {
                    const curb = BABYLON.MeshBuilder.CreateBox(`curb_${idxCar}_${side}_${i}`,
                        { width: 0.3, height: 0.2, depth: 4 }, sceneRef);
                    curb.position = new BABYLON.Vector3(car.x + side * 6, 0.1, i * 10);
                    curb.material = crearMaterial(`curbMat_${idxCar}_${side}_${i}`, COLORS.CURB, sceneRef);
                }
            }
        });

        // Líneas en curva
        for (let i = 0; i < curvePath.length; i += 7) {
            const p = curvePath[i];
            const p2 = curvePath[i + 1];
            const dir = p2.subtract(p);
            const angle = Math.atan2(dir.x, dir.z);

            const dash = BABYLON.MeshBuilder.CreateBox("lineCurve_" + i,
                { width: 0.5, height: 0.1, depth: 4 }, sceneRef);
            dash.position = new BABYLON.Vector3(p.x, 0.06, p.z);
            dash.rotation.y = angle;
            dash.material = crearMaterial("lineCurveMat_" + i, COLORS.LINE_ROAD, sceneRef);
        }
    }

    // Helper para crear casa + techo en una posición
    function crearCasaConTecho(sceneRef, x, z, index, prefix) {
        const house = BABYLON.MeshBuilder.CreateBox(`house_${prefix}_${index}`,
            { width: 4, height: 2, depth: 4 }, sceneRef);
        house.position = new BABYLON.Vector3(x, 1, z);
        house.material = crearMaterial(`houseMat_${prefix}_${index}`, COLORS.HOUSE_WALL, sceneRef);

        const roof = BABYLON.MeshBuilder.CreateBox(`roof_${prefix}_${index}`,
            { width: 4.2, height: 1, depth: 4.2 }, sceneRef);
        roof.position = new BABYLON.Vector3(x, 2.1, z);
        roof.material = crearMaterial(`roofMat_${prefix}_${index}`, COLORS.HOUSE_ROOF, sceneRef);
    }

    function crearCasas(sceneRef) {
        const casasPosiciones = [];

        // Casas carretera 1
        for (let i = 0; i < CONFIG.HOUSES_COUNT; i++) {
            const casaZ = i * CONFIG.HOUSE_OFFSET + CONFIG.HOUSE_INITIAL;

            crearCasaConTecho(sceneRef, -10, casaZ, i, "c1L");
            crearCasaConTecho(sceneRef, 10, casaZ, i, "c1R");

            casasPosiciones.push(new BABYLON.Vector3(-10, 0, casaZ));
            casasPosiciones.push(new BABYLON.Vector3(10, 0, casaZ));
        }

        // Casas carretera 2
        for (let i = 0; i < CONFIG.HOUSES_COUNT; i++) {
            const casaZ2 = i * CONFIG.HOUSE_OFFSET + CONFIG.HOUSE_INITIAL;
            const offsetX = CONFIG.ROAD2_POS.x;

            crearCasaConTecho(sceneRef, offsetX - 10, casaZ2, i, "c2L");
            crearCasaConTecho(sceneRef, offsetX + 10, casaZ2, i, "c2R");

            casasPosiciones.push(new BABYLON.Vector3(offsetX - 10, 0, casaZ2));
            casasPosiciones.push(new BABYLON.Vector3(offsetX + 10, 0, casaZ2));
        }

        return casasPosiciones;
    }

    function crearParedes(sceneRef, curvePath) {
        crearParedColision("wallLeft", { width: 0.5, height: 3, depth: 100 },
            new BABYLON.Vector3(-6.25, 1.5, CONFIG.ROAD1_POS.z), sceneRef);
        crearParedColision("wallRight", { width: 0.5, height: 3, depth: 100 },
            new BABYLON.Vector3(6.25, 1.5, CONFIG.ROAD1_POS.z), sceneRef);
        crearParedColision("wallLeft2_ext", { width: 0.5, height: 3, depth: 105 },
            new BABYLON.Vector3(CONFIG.ROAD2_POS.x - 6.25, 1.5, CONFIG.ROAD1_POS.z), sceneRef);
        crearParedColision("wallRight2_ext", { width: 0.5, height: 3, depth: 105 },
            new BABYLON.Vector3(CONFIG.ROAD2_POS.x + 6.25, 1.5, CONFIG.ROAD1_POS.z), sceneRef);

        // Paredes en la curva
        const halfWidthCurve = 6;
        const wallHeight = 3;
        const wallThickness = 0.5;

        for (let i = 0; i < curvePath.length - 1; i++) {
            const p = curvePath[i];
            const p2 = curvePath[i + 1];
            const dir = p2.subtract(p).normalize();
            const angle = Math.atan2(dir.x, dir.z);
            const normal = new BABYLON.Vector3(-dir.z, 0, dir.x);

            const posL = p.add(normal.scale(-halfWidthCurve));
            crearParedColision("wallCurve_L_" + i,
                { width: wallThickness, height: wallHeight, depth: 3 },
                new BABYLON.Vector3(posL.x, 1.5, posL.z), sceneRef, angle);

            const posR = p.add(normal.scale(halfWidthCurve));
            crearParedColision("wallCurve_R_" + i,
                { width: wallThickness, height: wallHeight, depth: 3 },
                new BABYLON.Vector3(posR.x, 1.5, posR.z), sceneRef, angle);
        }
    }

    // LÓGICA DEL JUEGO
    function generarPaciente() {
        const sceneRef = game.scene;
        const paciente = game.paciente;

        if (!sceneRef || !paciente) return;

        const carreteraIndex = Math.random() < 0.5 ? 0 : 1;
        const centrosX = [0, 30];
        const centroX = centrosX[carreteraIndex];
        const side = Math.random() < 0.5 ? -1 : 1;

        const bordeCarretera = 5.5;
        const offset = 0.8;
        const posX = centroX + side * (bordeCarretera + offset);
        const posZ = Math.random() * CONFIG.PATIENT_SPAWN_Z_RANGE;

        paciente.position = new BABYLON.Vector3(posX, 0, posZ);
        paciente.rotation = new BABYLON.Vector3(0, side === -1 ? Math.PI / 2 : -Math.PI / 2, 0);

        // Luz spotlight
        if (!game.patientLight) {
            game.patientLight = new BABYLON.SpotLight("patientSpot",
                new BABYLON.Vector3(posX, 0.2, posZ),
                new BABYLON.Vector3(0, 1, 0),
                Math.PI / 2.2, 25, sceneRef);
            game.patientLight.diffuse = new BABYLON.Color3(0.2, 0.7, 1);
            game.patientLight.specular = new BABYLON.Color3(0.2, 0.7, 1);
            game.patientLight.intensity = 2;
        } else {
            game.patientLight.position.set(posX, 0.2, posZ);
            game.patientLight.direction = new BABYLON.Vector3(0, 1, 0);
            game.patientLight.intensity = 2;
        }

        // Aros holográficos
        const numRings = 4;
        const baseRadius = 2.3;
        const ringGap = 0.5;

        if (game.patientRings.length === 0) {
            for (let i = 0; i < numRings; i++) {
                const points = [];
                const segments = 72;
                for (let a = 0; a <= segments; a++) {
                    const angle = (a / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * baseRadius;
                    const z = Math.sin(angle) * baseRadius;
                    points.push(new BABYLON.Vector3(x, 0, z));
                }

                const ring = BABYLON.MeshBuilder.CreateTube("holoRing" + i,
                    { path: points, radius: 0.10, tessellation: 32, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, sceneRef);

                const mat = new BABYLON.StandardMaterial("holoMat" + i, sceneRef);
                mat.emissiveColor = new BABYLON.Color3(0.4, 0.9, 1.2);
                mat.diffuseColor = new BABYLON.Color3(0, 0, 0);
                mat.specularColor = new BABYLON.Color3(0.4, 0.9, 1);
                mat.alpha = 0.8;
                ring.material = mat;
                ring.alwaysSelectAsActiveMesh = true;
                game.patientRings.push(ring);
            }
        }

        game.patientRings.forEach((ring, index) => {
            ring.position.x = posX;
            ring.position.z = posZ;
            ring.position.y = 0.1 + index * ringGap;
            ring.isVisible = true;
        });

        // Enfoque de cámara
        if (sceneRef.activeCamera && game.paciente && game.ambulancia) {
            const cam = sceneRef.activeCamera;
            cam.lockedTarget = paciente;
            setTimeout(() => {
                let t = 0;
                const duration = 30;
                const start = cam.position.clone();
                const end = cam.position.add(game.ambulancia.position.subtract(paciente.position));

                function smoothToAmbulancia() {
                    t++;
                    cam.position = BABYLON.Vector3.Lerp(start, end, t / duration);
                    if (t >= duration) {
                        let t2 = 0;
                        const duration2 = 30;
                        const start2 = cam.position.clone();
                        const zoomPos = game.ambulancia.position.add(new BABYLON.Vector3(0, 16, -25));

                        function zoomAmbulancia() {
                            t2++;
                            cam.position = BABYLON.Vector3.Lerp(start2, zoomPos, t2 / duration2);
                            cam.lockedTarget = game.ambulancia;
                            if (t2 >= duration2) {
                                sceneRef.onBeforeRenderObservable.removeCallback(zoomAmbulancia);
                            }
                        }
                        sceneRef.onBeforeRenderObservable.add(zoomAmbulancia);
                        sceneRef.onBeforeRenderObservable.removeCallback(smoothToAmbulancia);
                    }
                }
                sceneRef.onBeforeRenderObservable.add(smoothToAmbulancia);
            }, 1500);
        }
    }

    const createScene = function () {
        const sceneRef = new BABYLON.Scene(engine);
        sceneRef.collisionsEnabled = true;
        game.scene = sceneRef;

        // Cámara
        const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 10, -20), sceneRef);
        camera.radius = 30;
        camera.heightOffset = 8;
        camera.rotationOffset = 180;
        camera.attachControl(canvas, true);
        if (sceneRef.activeCamera) {
            sceneRef.activeCamera.checkCollisions = true;
            sceneRef.activeCamera.applyGravity = false;
        }

        // Color de fondo y luz
        sceneRef.clearColor = new BABYLON.Color3(0, 0, 0);
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), sceneRef);
        light.intensity = CONFIG.LIGHT_INTENSITY;

        // Crear escenario
        crearSkybox(sceneRef);
        const { roadMat } = crearCarreteras(sceneRef);
        const { curvePath } = crearCurva(sceneRef, roadMat);
        crearAceras(sceneRef, curvePath);
        crearDecoracion(sceneRef);
        crearLineasYBordes(sceneRef, curvePath);
        crearCasas(sceneRef);
        crearParedes(sceneRef, curvePath);

        // HUD
        const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const instrucciones = new BABYLON.GUI.TextBlock();
        instrucciones.text = "WASD para mover | Espacio para recoger/entregar";
        instrucciones.color = "black";
        instrucciones.fontSize = 24;
        instrucciones.top = "-45%";
        gui.addControl(instrucciones);

        const hudBox = new BABYLON.GUI.Rectangle();
        hudBox.width = "220px";
        hudBox.height = "50px";
        hudBox.cornerRadius = 8;
        hudBox.color = "#FFD700";
        hudBox.thickness = 2;
        hudBox.background = "#222";
        hudBox.top = "10px";
        hudBox.left = "10px";
        hudBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        hudBox.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        gui.addControl(hudBox);

        const contadorText = new BABYLON.GUI.TextBlock();
        contadorText.text = "Pacientes entregados: 0";
        contadorText.color = "yellow";
        contadorText.fontSize = 18;
        hudBox.addControl(contadorText);
        game.contadorText = contadorText;

        // Cargar modelos
        BABYLON.SceneLoader.ImportMesh("", "modelos/hospital/", "scene.gltf", sceneRef, function (meshes) {
            game.hospital = meshes[0];
            game.hospital.scaling = new BABYLON.Vector3(3, 3, 3);
            game.hospital.position = new BABYLON.Vector3(15, 0, 130);
        });

        BABYLON.SceneLoader.ImportMesh("", "modelos/ambulancia/", "scene.gltf", sceneRef, function (meshes) {
            game.ambulancia = meshes[0];
            game.ambulancia.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
            game.ambulancia.position = new BABYLON.Vector3(0, 0, 5);
            game.ambulancia.checkCollisions = true;
            game.ambulancia.ellipsoid = new BABYLON.Vector3(1.8, 1.5, 3);
            game.ambulancia.ellipsoidOffset = new BABYLON.Vector3(0, 1.5, 0);
            game.ambulancia.rotation = new BABYLON.Vector3(0, 0, 0);
            camera.lockedTarget = game.ambulancia;
        });

        BABYLON.SceneLoader.ImportMesh("", "modelos/persona/", "scene.gltf", sceneRef, function (meshes) {
            game.paciente = meshes[0];
            game.paciente.scaling = new BABYLON.Vector3(2, 2, 2);
            generarPaciente();
        });

        // Input
        sceneRef.actionManager = new BABYLON.ActionManager(sceneRef);
        sceneRef.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
            game.inputMap[evt.sourceEvent.key.toLowerCase()] = true;
        }));
        sceneRef.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
            game.inputMap[evt.sourceEvent.key.toLowerCase()] = false;
        }));

        // Recoger/Entregar paciente
        sceneRef.onKeyboardObservable.add((kbInfo) => {
            if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN && kbInfo.event.key === " ") {
                const ambulancia = game.ambulancia;
                const paciente = game.paciente;
                const hospital = game.hospital;

                if (!ambulancia || !paciente) return;

                if (!game.tienePaciente) {
                    let dist = BABYLON.Vector3.Distance(ambulancia.position, paciente.position);
                    if (dist < CONFIG.PATIENT_PICKUP_RANGE) {
                        paciente.parent = ambulancia;
                        paciente.position = new BABYLON.Vector3(0, 1, -1);
                        game.tienePaciente = true;

                        // Apagar holograma al recoger
                        game.patientRings.forEach(r => r.isVisible = false);
                        if (game.patientLight) game.patientLight.intensity = 0;
                    }
                } else if (hospital) {
                    const dropPoint = new BABYLON.Vector3(hospital.position.x, 0, hospital.position.z - 12);
                    let dist = BABYLON.Vector3.Distance(ambulancia.position, dropPoint);

                    if (dist < CONFIG.PATIENT_DELIVERY_RANGE) {
                        paciente.parent = null;
                        paciente.position = dropPoint.clone();
                        paciente.position.y = 0;
                        const toHospital = hospital.position.subtract(paciente.position);
                        paciente.rotation = new BABYLON.Vector3(0, Math.atan2(toHospital.x, toHospital.z), 0);
                        game.tienePaciente = false;
                        game.contadorPacientes++;
                        game.contadorText.text = `Pacientes entregados: ${game.contadorPacientes}`;
                        setTimeout(() => generarPaciente(), 300);
                    }
                }
            }
        });

        // Movimiento de ambulancia
        sceneRef.onBeforeRenderObservable.add(() => {
            const ambulancia = game.ambulancia;
            if (!ambulancia) return;

            if (ambulancia.rotationQuaternion) {
                ambulancia.rotation = ambulancia.rotationQuaternion.toEulerAngles();
                ambulancia.rotationQuaternion = null;
            }

            const rotY = ambulancia.rotation.y;
            const forward = new BABYLON.Vector3(Math.sin(rotY), 0, Math.cos(rotY));
            let movimiento = new BABYLON.Vector3(0, 0, 0);

            if (game.inputMap["w"]) movimiento = movimiento.add(forward.scale(CONFIG.AMBULANCE_SPEED));
            if (game.inputMap["s"]) movimiento = movimiento.add(forward.scale(-CONFIG.AMBULANCE_SPEED));
            if (game.inputMap["a"]) ambulancia.rotation.y -= CONFIG.AMBULANCE_ROTATION_SPEED;
            if (game.inputMap["d"]) ambulancia.rotation.y += CONFIG.AMBULANCE_ROTATION_SPEED;

            ambulancia.moveWithCollisions(movimiento);
            // Límites del escenario
            if (ambulancia.position.x < CONFIG.AMBULANCE_BOUNDS.minX) ambulancia.position.x = CONFIG.AMBULANCE_BOUNDS.minX;
            if (ambulancia.position.x > CONFIG.AMBULANCE_BOUNDS.maxX) ambulancia.position.x = CONFIG.AMBULANCE_BOUNDS.maxX;
            if (ambulancia.position.z < CONFIG.AMBULANCE_BOUNDS.minZ) ambulancia.position.z = CONFIG.AMBULANCE_BOUNDS.minZ;
            if (ambulancia.position.z > CONFIG.AMBULANCE_BOUNDS.maxZ) ambulancia.position.z = CONFIG.AMBULANCE_BOUNDS.maxZ;
        });

        // Animación del holograma
        sceneRef.onBeforeRenderObservable.add(() => {
            if (game.patientRings.length === 0) return;
            game.hologramTime += sceneRef.getEngine().getDeltaTime() / 1000;

            game.patientRings.forEach((ring, index) => {
                const t = game.hologramTime;
                const baseScale = 1 + 0.12 * Math.sin(t * 3 + index * 0.6);
                ring.scaling = new BABYLON.Vector3(baseScale, 1, baseScale);
                ring.rotation.y += 0.01 * (index + 1);
                const mat = ring.material;
                if (mat) {
                    mat.alpha = 0.4 + 0.2 * Math.sin(t * 4 + index);
                }
            });
        });
        return sceneRef;
    };

    game.scene = createScene();
    engine.runRenderLoop(() => game.scene.render());
    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>